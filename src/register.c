/*
 * @(#)register.c
 *
 * Copyright 2001-2002, Aaron Ardiri     (mailto:aaron@ardiri.com)
 *                      Charles Kerchner (mailto:chip@ardiri.com)
 * All rights reserved.
 *
 * This file was generated as part of the  "lemmings" program developed
 * for the Palm Computing Platform designed by Palm:
 *
 *   http://www.palm.com/
 *
 * The contents of this file is confidential and proprietrary in nature
 * ("Confidential Information"). Redistribution or modification without
 * prior consent of the original author is prohibited.
 */

#include "palm.h"

/**
 * Initialize the registration routines.
 *
 * @param the global preferences structure.
 */
void
RegisterInitialize(PreferencesType *prefs)
{
  StrCopy(prefs->system.signature, "|HaCkMe|");
}

/**
 * Display the "- DEMONSTRAION VERSION -" message on the screen if needed.
 *
 * @param the global preferences structure.
 */
void
RegisterShowMessage(PreferencesType *prefs)
{
  const RectangleType rect      = {{0,149},{160,14}};
  const CustomPatternType erase = {0,0,0,0,0,0,0,0};

  // we MUST be on the main form to do this
  if (FrmGetActiveFormID() == mainForm)
  {
    Coord x;
    Char  str[32];

    // erase the are behind
    WinSetPattern(&erase);
    WinFillRectangle(&rect, 0);

    // draw our status
    if (prefs->levelPack.type == PACK_INTERNAL)
      SysCopyStringResource(str, stringDemoMainPage);
    else
      SysCopyStringResource(str, stringRegisteredPack); // special = level pack
    x = (rect.extent.x - FntCharsWidth(str, StrLen(str))) >> 1;
    WinDrawChars(str, StrLen(str), x, rect.topLeft.y);
  }
}

/**
 * Generate a checksum of a data chunk.
 *
 * @param dataChunk a pointer to the chunk of data to decrypt.
 * @param dataChunkSize the size of the chunk of data to decrypt.
 */
UInt8
RegisterChecksum(UInt8 *dataChunk,
                 Int16 dataChunkSize)
{
  UInt8 key;
  Int16 i;

  // calculate a checksum of the data chunk
  key = 0;
  for (i=0; i<dataChunkSize; i++)
    key ^= dataChunk[i];

  return key;
}

/**
 * Decrypt a data chunk using an RC4 style algorithm.
 *
 * @param dataChunk a pointer to the chunk of data to decrypt.
 * @param dataChunkSize the size of the chunk of data to decrypt.
 * @param keyResource the resource handle of the key
 * @param key the starting key value, zero if autogenerated.
 */
void
RegisterDecryptChunk(UInt8     *dataChunk,
                     Int16     dataChunkSize,
                     MemHandle keyResource,
                     UInt8     key)
{
  UInt8 *keyChunk;
  Int16 i, index, keyChunkSize;

  //
  // NOTE: the decryption/encryption is similar to the RC4 (USA military)
  //       method for securing data. RC4 can be applied twice to get the
  //       original data (as it is an XOR based algorithm). The 'key' used
  //       by this algorithm is the "register" code segment. After each
  //       byte is adjusted, the key is dynamically updated using a simple
  //       "windowing" effect.
  //
  //       *all* code used for registration purposes is placed in the
  //       "register" code segment. patching this segment will create an
  //       invalid 'key' data set and decryption will result in the Palm
  //       device giving FATAL EXCEPTIONS upon execution of the data chunks.
  //
  //                                                      Aaron Ardiri, 2000

  keyChunkSize = MemHandleSize(keyResource);
  keyChunk     = (UInt8 *)MemHandleLock(keyResource);

  // what is our starting value?
  key = (key == 0) ? RegisterChecksum(keyChunk, keyChunkSize) : key;

  // decrypt our data chunk, using an RC4 level algorithm
  index = key;
  for (i=0; i<dataChunkSize; i++)
  {
    // adjust the byte
    dataChunk[i] ^= key;

    // dynamically update the key
    do
    {
      index = (index + key + 1) % keyChunkSize;
      key   = keyChunk[index];
    }
    while (key == 0);
  }

  MemHandleUnlock(keyResource);
}

/**
 * Terminate the registration routines.
 */
void
RegisterTerminate()
{
}

#ifdef MDM_DISTRIBUTION

static Err MDM_NextLine(FileRef fileRef)                               __REGISTER__;
static Err MDM_ReadLine(FileRef fileRef, char *buf, UInt32 *bufLenPtr) __REGISTER__;

/**
 * This routine seeks to the next line in a file on MMC card
 *
 * @param fileRef file reference.
 * @return errNone if no error, error code otherwise.
 */
static Err
MDM_NextLine(FileRef fileRef)
{
	Err 	err = errNone;
	Boolean	bEOL;
	UInt32	numBytes = 1;	// Read one byte at a time
	UInt32	numBytesRead;
	char	charBuf;

	bEOL = false;
	while (!bEOL)
	{
		// Read a character from the file
		numBytesRead = 1;
		err = VFSFileRead(fileRef, numBytes, &charBuf, &numBytesRead);
		if (err != errNone) return err;

		// Look for the <CR>
		if (charBuf == 0x0D)
		{
			// Read another character from the file
			numBytesRead = 1;
			err = VFSFileRead(fileRef, numBytes, &charBuf, &numBytesRead);
			if (err != errNone) return err;

			// Check to make sure it is a <LF>
			if (charBuf == 0x0A)
			{
				// Found a <CR><LF> pair
				bEOL = true;
			}
		}
	}

	return err;
}

/**
 * This routine reads the next line in a file on MMC card to a buffer.
 *
 * @param fileRef   file reference.
 * @param buf       buffer to write to
 * @param bufLenPtr pointer to length of buffer.
 * @return errNone if no error, error code otherwise.
 */
static Err
MDM_ReadLine(FileRef fileRef, char *buf, UInt32 *bufLenPtr)
{
	Err 	err = errNone;
	UInt32	startPos;
	UInt32	endPos;
	UInt32	numBytesToRead;

	// Save the current position in file
	err = VFSFileTell(fileRef, &startPos);
	if (err != errNone) return err;

	// Seek to the next line
	err = MDM_NextLine(fileRef);
	if ((err == errNone) || (err == vfsErrFileEOF))
	{
		// Save the current position in file
		err = VFSFileTell(fileRef, &endPos);
		if (err != errNone) return err;

		// Seek back to the beginning of the line
		err = VFSFileSeek(fileRef, vfsOriginBeginning, startPos);
		if (err != errNone) return err;

		// Read the line
		numBytesToRead = endPos - startPos;
		err = VFSFileRead(fileRef, numBytesToRead, buf, bufLenPtr);
	}

	return err;
}


/**
 * This routine reads the registration key from the file on MMC card.
 *
 * @param fileRef   file reference.
 * @param buf       buffer to write to
 * @param bufLenPtr pointer to length of buffer.
 * @return errNone if no error, error code otherwise.
 */
Err
MDM_GetKey(UInt8 *buf, UInt32 *bufLenPtr)
{
	Err	err = errNone;
	UInt32	volIterator, slotIterator;
	UInt16	volRefNum, slotRef;
	UInt16	line;
	FileRef	fileRef;
	char    filePathName[] = "/Palm/PALMRegSDMMC.txt";
	UInt16  index          = 0;
	ExpCardInfoType cardInfo;

	// Search all volumes for the file
	volRefNum = 0;
	volIterator = expIteratorStart;
	while (volIterator != expIteratorStop)
	{
		// Get the volRefNum for the next volume
		err = VFSVolumeEnumerate(&volRefNum, &volIterator);
		if (err != errNone) return err;

		// Try to open the registration key file on this volume
		err = VFSFileOpen(volRefNum, filePathName, vfsModeRead, &fileRef);
		if (err != errNone) return err;

		// We have found the key file, seek past lines we don't care about
		line = 0;
		while (line < index)
		{
			// Skip a line in the file
			err = MDM_NextLine(fileRef);
			if (err != errNone) return err;
			line++;
		}

		// We are now positioned at our key, so read it
		err = MDM_ReadLine(fileRef, buf, bufLenPtr);
		if (err != errNone) return err;

		// Strip the CRLF and place an EOS character
		if ((buf[*bufLenPtr-2] == 0x0D) && (buf[*bufLenPtr-1] == 0x0A))
			buf[*bufLenPtr-2] = 0;
		else
			buf[*bufLenPtr] = 0;
	}

	return err;
}
#endif
